import path from 'path'
import pathUtil from 'path'
import { IFieldTemplateItem, ISchemaTemplateItem } from '@sprucelabs/schema'
import {
	templates,
	IDefinitionBuilderTemplateItem
} from '@sprucelabs/spruce-templates'
import ErrorCode from '#spruce/errors/errorCode'
import { LATEST_HANDLEBARS } from '../constants'
import SpruceError from '../errors/SpruceError'
import { IGeneratedFile } from '../types/cli.types'
import diskUtil from '../utilities/disk.utility'
import namesUtil from '../utilities/names.utility'
import versionUtil from '../utilities/version.utility'
import AbstractGenerator from './AbstractGenerator'

export interface IGenerateSchemaTypesOptions {
	fieldTemplateItems: IFieldTemplateItem[]
	schemaTemplateItems: ISchemaTemplateItem[]
	clean?: boolean
}

export interface IGenerateFieldTypesOptions {
	fieldTemplateItems: IFieldTemplateItem[]
	clean?: boolean
}

export interface IGenerateSchemaTypesOptions {
	fieldTemplateItems: IFieldTemplateItem[]
	schemaTemplateItems: ISchemaTemplateItem[]
	clean?: boolean
}

export interface ISchemaGeneratorBuildResults {
	generatedFiles: IGeneratedFile[]
}

export interface ISchemaGeneratorValueTypeResults {
	generatedFiles: IGeneratedFile[]
}

export interface ISchemaGeneratorFieldResults {
	generatedFiles: IGeneratedFile[]
	updatedFiles: IGeneratedFile[]
}

export interface ISchemaGeneratorSchemaSyncResults {
	resultsByStage: ISchemaTypesGenerationStage[]
	generatedFiles: IGeneratedFile[]
	updatedFiles: IGeneratedFile[]
}

export interface ISchemaTypesGenerationStage {
	name: string
	errors: SpruceError[]
	successfulSchemas: number
	successfulFields: number
}
export default class SchemaGenerator extends AbstractGenerator {
	private readonly fieldTemplates: {
		filename: string
		templateFuncName: 'fieldsTypes' | 'fieldClassMap' | 'fieldType'
		nameReadable: string
		description: string
	}[] = [
		{
			filename: 'fields.types.ts',
			templateFuncName: 'fieldsTypes',
			nameReadable: 'Field types',
			description:
				'All the interfaces generated for every type of schema field (text, number, address, etc)'
		},
		{
			filename: 'fieldClassMap.ts',
			templateFuncName: 'fieldClassMap',
			nameReadable: 'Field class map',
			description:
				'An object that is injected into the FieldFactory and ensures 3rd party fields are integrated'
		},
		{
			filename: 'fieldType.ts',
			templateFuncName: 'fieldType',
			nameReadable: 'Field type enum',
			description:
				'This is your autogenerated, skill-specific enumeration of all the fields you have access to'
		}
	]

	public async generateBuilder(
		destinationDir: string,
		options: IDefinitionBuilderTemplateItem
	): Promise<ISchemaGeneratorBuildResults> {
		const resolvedBuilderDestination = versionUtil.resolveNewLatestPath(
			destinationDir,
			LATEST_HANDLEBARS,
			`${options.nameCamel}.builder.ts`
		)

		const definitionBuilder = templates.definitionBuilder(options)

		await diskUtil.writeFile(resolvedBuilderDestination, definitionBuilder)

		return {
			generatedFiles: [
				{
					name: 'Builder',
					path: resolvedBuilderDestination,
					description: 'The file from which all '
				}
			]
		}
	}

	public async generateFieldTypes(
		destinationDir: string,
		options: IGenerateFieldTypesOptions
	): Promise<ISchemaGeneratorFieldResults> {
		const { fieldTemplateItems } = options

		const results: ISchemaGeneratorFieldResults = {
			generatedFiles: [],
			updatedFiles: []
		}

		this.fieldTemplates.forEach(fileAndFunc => {
			const {
				filename,
				templateFuncName,
				nameReadable,
				description
			} = fileAndFunc

			const resolvedDestination = path.join(destinationDir, 'fields', filename)

			const contents = templates[templateFuncName]({
				fieldTemplateItems
			})

			diskUtil.writeFile(resolvedDestination, contents)

			results.generatedFiles.push({
				name: nameReadable,
				description,
				path: resolvedDestination
			})
		})

		return results
	}

	public async generateSchemaTypes(
		destinationDir: string,
		options: IGenerateSchemaTypesOptions
	): Promise<ISchemaGeneratorSchemaSyncResults> {
		const { fieldTemplateItems, schemaTemplateItems } = options

		const schemaTypesDestination = path.join(destinationDir, 'schemas.types.ts')

		// Generate in stages, starting with core only
		const coreSchemaTemplateItems = schemaTemplateItems.filter(
			i => i.namespace === 'Core'
		)

		const coreFieldTemplateItems = fieldTemplateItems.filter(
			i => i.package === '@sprucelabs/schema'
		)

		const stages = [
			{
				// Stage 1, core
				name: 'core',
				schemaTemplateItems: coreSchemaTemplateItems,
				fieldTemplateItems: coreFieldTemplateItems
			},
			{
				// Stage 2, everything
				name: 'everything',
				schemaTemplateItems,
				fieldTemplateItems
			}
		]

		const resultsByStage = []
		const normalizedDefinitions: {
			id: string
			name: string
			path: string
			description: string
		}[] = []

		let successfulSchemas = 0
		let successfulFields = 0

		for (const stage of stages) {
			const {
				schemaTemplateItems: schemaTemplateItemsStage,
				fieldTemplateItems,
				name
			} = stage
			try {
				// We may need to remove template items if they error below
				let schemaTemplateItems = [...schemaTemplateItemsStage]

				successfulFields += fieldTemplateItems.length

				// Build the ValueType hash to pass to schemasTypes
				const {
					valueTypes,
					errors
					//@ts-ignore
				} = await this.valueTypeService.allValueTypes({
					schemaTemplateItems,
					fieldTemplateItems
				})

				// If there were errors, remove any definitions that had them
				if (errors.length > 0) {
					//@ts-ignore
					errors.forEach(err => {
						const { options } = err
						if (options.code === ErrorCode.ValueTypeServiceError) {
							schemaTemplateItems = schemaTemplateItems.filter(
								item => item.id !== options.schemaId
							)
						}
					})
				}
				// definitions for each schema
				await Promise.all(
					schemaTemplateItems.map(async templateItem => {
						// only normalize this schema once for all stages
						if (!normalizedDefinitions.find(n => n.id === templateItem.id)) {
							const destination = path.join(
								destinationDir,
								namesUtil.toCamel(templateItem.namespace),
								`${templateItem.nameCamel}.definition.ts`
							)

							const definition = templates.definition({
								...templateItem,
								schemaTemplateItems,
								fieldTemplateItems,
								valueTypes
							})

							await diskUtil.writeFile(destination, definition)

							normalizedDefinitions.push({
								name: `${templateItem.namePascal} definition`,
								id: templateItem.namePascal,
								path: destination,
								description:
									templateItem.definition.description ??
									`*** no description defined in ${destination} ***`
							})

							successfulSchemas++
						}
					})
				)

				// Schema types
				const schemaTypesContents = templates.schemasTypes({
					schemaTemplateItems,
					fieldTemplateItems,
					valueTypes
				})

				//Write out schema types
				await diskUtil.writeFile(schemaTypesDestination, schemaTypesContents)

				resultsByStage.push({
					name,
					errors,
					successfulSchemas: schemaTemplateItems.length,
					successfulFields: fieldTemplateItems.length
				})
			} catch (err) {
				resultsByStage.push({
					name,
					errors: [
						new SpruceError({
							code: ErrorCode.ValueTypeServiceStageError,
							stage: name,
							originalError: err
						})
					],
					successfulFields,
					successfulSchemas
				})
			}
		}

		return {
			resultsByStage,
			updatedFiles: [],
			generatedFiles: [
				{
					name: 'Schema types',
					path: schemaTypesDestination,
					description:
						'Registry of types, e.g. SpruceSchemas.Local.2020_01_10.Ball'
				},
				...normalizedDefinitions
			]
		}
	}

	public async generateValueTypes(
		destinationDir: string,
		options: {
			schemaTemplateItems: ISchemaTemplateItem[]
			fieldTemplateItems: IFieldTemplateItem[]
		}
	): Promise<ISchemaGeneratorValueTypeResults> {
		const contents = this.templates.valueTypes(options)
		const destination = pathUtil.join(destinationDir, 'valueType.tmp.ts')

		diskUtil.writeFile(destination, contents)

		return {
			generatedFiles: [
				{
					name: 'Value type builder',
					path: destination,
					description:
						'For constructing what goes to the right of the : after each property in the interface.'
				}
			]
		}
	}
}
