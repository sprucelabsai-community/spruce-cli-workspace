// Import base class
import {{abstractClassName}} from '{{abstractClassRelativePath}}'

// Import each matching class that will be autoloaded
{{#each classes}}
import {{className}} from '{{relativeFilePath}}'
{{/each}}

// Import necessary interface(s)
{{#each interfaces}}
import { {{interfaceName}} } from '{{relativeFilePath}}'
{{/each}}

export interface I{{namePlural}} {
	{{#each classes}}
	{{camelCase className}}: {{className}}
	{{/each}}
}

export enum {{nameSingular}} {
	{{#each classes}}
	{{className}} = '{{camelCase className}}',
	{{/each}}
}

export default async function autoloader(options: {
	constructorOptions: {{#each interfaces}}{{#if @first}}{{interfaceName}}{{else}} | {{interfaceName}}{{/if}}{{/each}}
	after?: (instance: {{abstractClassName}}) => Promise<void>
}): Promise<I{{namePlural}}> {
	const { constructorOptions, after } = options

	{{#each classes}}
	const {{camelCase className}} = new {{className}}(constructorOptions)
	if (after) {
		await after({{camelCase className}})
	}
	{{/each}}

	const siblings: I{{namePlural}} = {
		{{#each classes}}
		{{#if @last}}
		{{camelCase className}}
		{{else}}
		{{camelCase className}},
		{{/if}}
		{{/each}}
	}

	{{#each classes}}
	// @ts-ignore method is optional
	if (typeof {{camelCase className}}.afterAutoload === 'function') {
		// @ts-ignore method is optional
		{{camelCase className}}.afterAutoload(siblings)
	}
	{{/each}}

	return siblings
}
